// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: uber/cadence/api/v1/common.proto

package apiv1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EncodingType int32

const (
	EncodingType_ENCODING_TYPE_INVALID  EncodingType = 0
	EncodingType_ENCODING_TYPE_THRIFTRW EncodingType = 1
	EncodingType_ENCODING_TYPE_JSON     EncodingType = 2
	EncodingType_ENCODING_TYPE_PROTO3   EncodingType = 3
)

var EncodingType_name = map[int32]string{
	0: "ENCODING_TYPE_INVALID",
	1: "ENCODING_TYPE_THRIFTRW",
	2: "ENCODING_TYPE_JSON",
	3: "ENCODING_TYPE_PROTO3",
}

var EncodingType_value = map[string]int32{
	"ENCODING_TYPE_INVALID":  0,
	"ENCODING_TYPE_THRIFTRW": 1,
	"ENCODING_TYPE_JSON":     2,
	"ENCODING_TYPE_PROTO3":   3,
}

func (x EncodingType) String() string {
	return proto.EnumName(EncodingType_name, int32(x))
}

func (EncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{0}
}

type IsolationGroupState int32

const (
	IsolationGroupState_ISOLATION_GROUP_STATE_INVALID IsolationGroupState = 0
	IsolationGroupState_ISOLATION_GROUP_STATE_HEALTHY IsolationGroupState = 1
	IsolationGroupState_ISOLATION_GROUP_STATE_DRAINED IsolationGroupState = 2
)

var IsolationGroupState_name = map[int32]string{
	0: "ISOLATION_GROUP_STATE_INVALID",
	1: "ISOLATION_GROUP_STATE_HEALTHY",
	2: "ISOLATION_GROUP_STATE_DRAINED",
}

var IsolationGroupState_value = map[string]int32{
	"ISOLATION_GROUP_STATE_INVALID": 0,
	"ISOLATION_GROUP_STATE_HEALTHY": 1,
	"ISOLATION_GROUP_STATE_DRAINED": 2,
}

func (x IsolationGroupState) String() string {
	return proto.EnumName(IsolationGroupState_name, int32(x))
}

func (IsolationGroupState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{1}
}

type ActiveClusterSelectionStrategy int32

const (
	ActiveClusterSelectionStrategy_ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID         ActiveClusterSelectionStrategy = 0
	ActiveClusterSelectionStrategy_ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY   ActiveClusterSelectionStrategy = 1
	ActiveClusterSelectionStrategy_ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY ActiveClusterSelectionStrategy = 2
)

var ActiveClusterSelectionStrategy_name = map[int32]string{
	0: "ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID",
	1: "ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY",
	2: "ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY",
}

var ActiveClusterSelectionStrategy_value = map[string]int32{
	"ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID":         0,
	"ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY":   1,
	"ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY": 2,
}

func (x ActiveClusterSelectionStrategy) String() string {
	return proto.EnumName(ActiveClusterSelectionStrategy_name, int32(x))
}

func (ActiveClusterSelectionStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{2}
}

type WorkflowExecution struct {
	WorkflowId           string   `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId                string   `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowExecution) Reset()         { *m = WorkflowExecution{} }
func (m *WorkflowExecution) String() string { return proto.CompactTextString(m) }
func (*WorkflowExecution) ProtoMessage()    {}
func (*WorkflowExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{0}
}
func (m *WorkflowExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowExecution.Merge(m, src)
}
func (m *WorkflowExecution) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowExecution.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowExecution proto.InternalMessageInfo

func (m *WorkflowExecution) GetWorkflowId() string {
	if m != nil {
		return m.WorkflowId
	}
	return ""
}

func (m *WorkflowExecution) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

type WorkflowType struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkflowType) Reset()         { *m = WorkflowType{} }
func (m *WorkflowType) String() string { return proto.CompactTextString(m) }
func (*WorkflowType) ProtoMessage()    {}
func (*WorkflowType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{1}
}
func (m *WorkflowType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowType.Merge(m, src)
}
func (m *WorkflowType) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowType) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowType.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowType proto.InternalMessageInfo

func (m *WorkflowType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ActivityType struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivityType) Reset()         { *m = ActivityType{} }
func (m *ActivityType) String() string { return proto.CompactTextString(m) }
func (*ActivityType) ProtoMessage()    {}
func (*ActivityType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{2}
}
func (m *ActivityType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityType.Merge(m, src)
}
func (m *ActivityType) XXX_Size() int {
	return m.Size()
}
func (m *ActivityType) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityType.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityType proto.InternalMessageInfo

func (m *ActivityType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Payload struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{3}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Failure struct {
	Reason               string   `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
	Details              []byte   `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Failure) Reset()         { *m = Failure{} }
func (m *Failure) String() string { return proto.CompactTextString(m) }
func (*Failure) ProtoMessage()    {}
func (*Failure) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{4}
}
func (m *Failure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Failure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Failure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Failure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Failure.Merge(m, src)
}
func (m *Failure) XXX_Size() int {
	return m.Size()
}
func (m *Failure) XXX_DiscardUnknown() {
	xxx_messageInfo_Failure.DiscardUnknown(m)
}

var xxx_messageInfo_Failure proto.InternalMessageInfo

func (m *Failure) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Failure) GetDetails() []byte {
	if m != nil {
		return m.Details
	}
	return nil
}

type Memo struct {
	Fields               map[string]*Payload `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Memo) Reset()         { *m = Memo{} }
func (m *Memo) String() string { return proto.CompactTextString(m) }
func (*Memo) ProtoMessage()    {}
func (*Memo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{5}
}
func (m *Memo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Memo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Memo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Memo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memo.Merge(m, src)
}
func (m *Memo) XXX_Size() int {
	return m.Size()
}
func (m *Memo) XXX_DiscardUnknown() {
	xxx_messageInfo_Memo.DiscardUnknown(m)
}

var xxx_messageInfo_Memo proto.InternalMessageInfo

func (m *Memo) GetFields() map[string]*Payload {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Header struct {
	Fields               map[string]*Payload `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{6}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetFields() map[string]*Payload {
	if m != nil {
		return m.Fields
	}
	return nil
}

type SearchAttributes struct {
	IndexedFields        map[string]*Payload `protobuf:"bytes,1,rep,name=indexed_fields,json=indexedFields,proto3" json:"indexed_fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SearchAttributes) Reset()         { *m = SearchAttributes{} }
func (m *SearchAttributes) String() string { return proto.CompactTextString(m) }
func (*SearchAttributes) ProtoMessage()    {}
func (*SearchAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{7}
}
func (m *SearchAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchAttributes.Merge(m, src)
}
func (m *SearchAttributes) XXX_Size() int {
	return m.Size()
}
func (m *SearchAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_SearchAttributes proto.InternalMessageInfo

func (m *SearchAttributes) GetIndexedFields() map[string]*Payload {
	if m != nil {
		return m.IndexedFields
	}
	return nil
}

type DataBlob struct {
	EncodingType         EncodingType `protobuf:"varint,1,opt,name=encoding_type,json=encodingType,proto3,enum=uber.cadence.api.v1.EncodingType" json:"encoding_type,omitempty"`
	Data                 []byte       `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DataBlob) Reset()         { *m = DataBlob{} }
func (m *DataBlob) String() string { return proto.CompactTextString(m) }
func (*DataBlob) ProtoMessage()    {}
func (*DataBlob) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{8}
}
func (m *DataBlob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataBlob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataBlob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataBlob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataBlob.Merge(m, src)
}
func (m *DataBlob) XXX_Size() int {
	return m.Size()
}
func (m *DataBlob) XXX_DiscardUnknown() {
	xxx_messageInfo_DataBlob.DiscardUnknown(m)
}

var xxx_messageInfo_DataBlob proto.InternalMessageInfo

func (m *DataBlob) GetEncodingType() EncodingType {
	if m != nil {
		return m.EncodingType
	}
	return EncodingType_ENCODING_TYPE_INVALID
}

func (m *DataBlob) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WorkerVersionInfo struct {
	Impl                 string   `protobuf:"bytes,1,opt,name=impl,proto3" json:"impl,omitempty"`
	FeatureVersion       string   `protobuf:"bytes,2,opt,name=feature_version,json=featureVersion,proto3" json:"feature_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkerVersionInfo) Reset()         { *m = WorkerVersionInfo{} }
func (m *WorkerVersionInfo) String() string { return proto.CompactTextString(m) }
func (*WorkerVersionInfo) ProtoMessage()    {}
func (*WorkerVersionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{9}
}
func (m *WorkerVersionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerVersionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerVersionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerVersionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerVersionInfo.Merge(m, src)
}
func (m *WorkerVersionInfo) XXX_Size() int {
	return m.Size()
}
func (m *WorkerVersionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerVersionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerVersionInfo proto.InternalMessageInfo

func (m *WorkerVersionInfo) GetImpl() string {
	if m != nil {
		return m.Impl
	}
	return ""
}

func (m *WorkerVersionInfo) GetFeatureVersion() string {
	if m != nil {
		return m.FeatureVersion
	}
	return ""
}

type SupportedClientVersions struct {
	// Indicates the highest Go SDK version server will accept requests from.
	GoSdk string `protobuf:"bytes,1,opt,name=go_sdk,json=goSdk,proto3" json:"go_sdk,omitempty"`
	// Indicates the highest Java SDK version server will accept requests from.
	JavaSdk              string   `protobuf:"bytes,2,opt,name=java_sdk,json=javaSdk,proto3" json:"java_sdk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SupportedClientVersions) Reset()         { *m = SupportedClientVersions{} }
func (m *SupportedClientVersions) String() string { return proto.CompactTextString(m) }
func (*SupportedClientVersions) ProtoMessage()    {}
func (*SupportedClientVersions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{10}
}
func (m *SupportedClientVersions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportedClientVersions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportedClientVersions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupportedClientVersions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportedClientVersions.Merge(m, src)
}
func (m *SupportedClientVersions) XXX_Size() int {
	return m.Size()
}
func (m *SupportedClientVersions) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportedClientVersions.DiscardUnknown(m)
}

var xxx_messageInfo_SupportedClientVersions proto.InternalMessageInfo

func (m *SupportedClientVersions) GetGoSdk() string {
	if m != nil {
		return m.GoSdk
	}
	return ""
}

func (m *SupportedClientVersions) GetJavaSdk() string {
	if m != nil {
		return m.JavaSdk
	}
	return ""
}

type RetryPolicy struct {
	// Interval of the first retry. If backoffCoefficient is 1.0 then it is used for all retries.
	InitialInterval *types.Duration `protobuf:"bytes,1,opt,name=initial_interval,json=initialInterval,proto3" json:"initial_interval,omitempty"`
	// Coefficient used to calculate the next retry interval.
	// The next retry interval is previous interval multiplied by the coefficient.
	// Must be 1 or larger.
	BackoffCoefficient float64 `protobuf:"fixed64,2,opt,name=backoff_coefficient,json=backoffCoefficient,proto3" json:"backoff_coefficient,omitempty"`
	// Maximum interval between retries. Exponential backoff leads to interval increase.
	// This value is the cap of the increase. Default is 100x of initial interval.
	MaximumInterval *types.Duration `protobuf:"bytes,3,opt,name=maximum_interval,json=maximumInterval,proto3" json:"maximum_interval,omitempty"`
	// Maximum number of attempts. When exceeded the retries stop even if not expired yet.
	// Must be 1 or bigger. Default is unlimited.
	MaximumAttempts int32 `protobuf:"varint,4,opt,name=maximum_attempts,json=maximumAttempts,proto3" json:"maximum_attempts,omitempty"`
	// Non-Retryable errors. Will stop retrying if error type matches this list.
	NonRetryableErrorReasons []string `protobuf:"bytes,5,rep,name=non_retryable_error_reasons,json=nonRetryableErrorReasons,proto3" json:"non_retryable_error_reasons,omitempty"`
	// Expiration time for the whole retry process.
	ExpirationInterval   *types.Duration `protobuf:"bytes,6,opt,name=expiration_interval,json=expirationInterval,proto3" json:"expiration_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RetryPolicy) Reset()         { *m = RetryPolicy{} }
func (m *RetryPolicy) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy) ProtoMessage()    {}
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{11}
}
func (m *RetryPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetryPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetryPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy.Merge(m, src)
}
func (m *RetryPolicy) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy proto.InternalMessageInfo

func (m *RetryPolicy) GetInitialInterval() *types.Duration {
	if m != nil {
		return m.InitialInterval
	}
	return nil
}

func (m *RetryPolicy) GetBackoffCoefficient() float64 {
	if m != nil {
		return m.BackoffCoefficient
	}
	return 0
}

func (m *RetryPolicy) GetMaximumInterval() *types.Duration {
	if m != nil {
		return m.MaximumInterval
	}
	return nil
}

func (m *RetryPolicy) GetMaximumAttempts() int32 {
	if m != nil {
		return m.MaximumAttempts
	}
	return 0
}

func (m *RetryPolicy) GetNonRetryableErrorReasons() []string {
	if m != nil {
		return m.NonRetryableErrorReasons
	}
	return nil
}

func (m *RetryPolicy) GetExpirationInterval() *types.Duration {
	if m != nil {
		return m.ExpirationInterval
	}
	return nil
}

type IsolationGroupPartition struct {
	Name                 string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State                IsolationGroupState `protobuf:"varint,2,opt,name=state,proto3,enum=uber.cadence.api.v1.IsolationGroupState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *IsolationGroupPartition) Reset()         { *m = IsolationGroupPartition{} }
func (m *IsolationGroupPartition) String() string { return proto.CompactTextString(m) }
func (*IsolationGroupPartition) ProtoMessage()    {}
func (*IsolationGroupPartition) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{12}
}
func (m *IsolationGroupPartition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsolationGroupPartition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsolationGroupPartition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsolationGroupPartition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsolationGroupPartition.Merge(m, src)
}
func (m *IsolationGroupPartition) XXX_Size() int {
	return m.Size()
}
func (m *IsolationGroupPartition) XXX_DiscardUnknown() {
	xxx_messageInfo_IsolationGroupPartition.DiscardUnknown(m)
}

var xxx_messageInfo_IsolationGroupPartition proto.InternalMessageInfo

func (m *IsolationGroupPartition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IsolationGroupPartition) GetState() IsolationGroupState {
	if m != nil {
		return m.State
	}
	return IsolationGroupState_ISOLATION_GROUP_STATE_INVALID
}

type IsolationGroupConfiguration struct {
	IsolationGroups      []*IsolationGroupPartition `protobuf:"bytes,1,rep,name=isolation_groups,json=isolationGroups,proto3" json:"isolation_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *IsolationGroupConfiguration) Reset()         { *m = IsolationGroupConfiguration{} }
func (m *IsolationGroupConfiguration) String() string { return proto.CompactTextString(m) }
func (*IsolationGroupConfiguration) ProtoMessage()    {}
func (*IsolationGroupConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{13}
}
func (m *IsolationGroupConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsolationGroupConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsolationGroupConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsolationGroupConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsolationGroupConfiguration.Merge(m, src)
}
func (m *IsolationGroupConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *IsolationGroupConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_IsolationGroupConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_IsolationGroupConfiguration proto.InternalMessageInfo

func (m *IsolationGroupConfiguration) GetIsolationGroups() []*IsolationGroupPartition {
	if m != nil {
		return m.IsolationGroups
	}
	return nil
}

type AsyncWorkflowConfiguration struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// predefined_queue_name is the name of the predefined queue in cadence server config's asyncWorkflowQueues
	PredefinedQueueName string `protobuf:"bytes,2,opt,name=predefined_queue_name,json=predefinedQueueName,proto3" json:"predefined_queue_name,omitempty"`
	// queue_type is the type of the queue if predefined_queue_name is not used
	QueueType string `protobuf:"bytes,3,opt,name=queue_type,json=queueType,proto3" json:"queue_type,omitempty"`
	// queue_config is the configuration for the queue if predefined_queue_name is not used
	QueueConfig          *DataBlob `protobuf:"bytes,4,opt,name=queue_config,json=queueConfig,proto3" json:"queue_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AsyncWorkflowConfiguration) Reset()         { *m = AsyncWorkflowConfiguration{} }
func (m *AsyncWorkflowConfiguration) String() string { return proto.CompactTextString(m) }
func (*AsyncWorkflowConfiguration) ProtoMessage()    {}
func (*AsyncWorkflowConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{14}
}
func (m *AsyncWorkflowConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsyncWorkflowConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AsyncWorkflowConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AsyncWorkflowConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsyncWorkflowConfiguration.Merge(m, src)
}
func (m *AsyncWorkflowConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *AsyncWorkflowConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_AsyncWorkflowConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_AsyncWorkflowConfiguration proto.InternalMessageInfo

func (m *AsyncWorkflowConfiguration) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AsyncWorkflowConfiguration) GetPredefinedQueueName() string {
	if m != nil {
		return m.PredefinedQueueName
	}
	return ""
}

func (m *AsyncWorkflowConfiguration) GetQueueType() string {
	if m != nil {
		return m.QueueType
	}
	return ""
}

func (m *AsyncWorkflowConfiguration) GetQueueConfig() *DataBlob {
	if m != nil {
		return m.QueueConfig
	}
	return nil
}

type ActiveClusterSelectionPolicy struct {
	Strategy ActiveClusterSelectionStrategy `protobuf:"varint,1,opt,name=strategy,proto3,enum=uber.cadence.api.v1.ActiveClusterSelectionStrategy" json:"strategy,omitempty"`
	// sticky_region is the region sticky if strategy is ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY
	// This is the default strategy for active-active domains and region would be set to receiver cluster's region if not specified.
	StickyRegion string `protobuf:"bytes,2,opt,name=sticky_region,json=stickyRegion,proto3" json:"sticky_region,omitempty"`
	// external_entity_type/external_entity_key is the type/key of the external entity if strategy is ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY
	// external entity type must be one of the supported types in active cluster manager. Custom ones can be added by implementing the corresponding interface.
	ExternalEntityType   string   `protobuf:"bytes,3,opt,name=external_entity_type,json=externalEntityType,proto3" json:"external_entity_type,omitempty"`
	ExternalEntityKey    string   `protobuf:"bytes,4,opt,name=external_entity_key,json=externalEntityKey,proto3" json:"external_entity_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActiveClusterSelectionPolicy) Reset()         { *m = ActiveClusterSelectionPolicy{} }
func (m *ActiveClusterSelectionPolicy) String() string { return proto.CompactTextString(m) }
func (*ActiveClusterSelectionPolicy) ProtoMessage()    {}
func (*ActiveClusterSelectionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ff151d4a308b356, []int{15}
}
func (m *ActiveClusterSelectionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveClusterSelectionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveClusterSelectionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveClusterSelectionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveClusterSelectionPolicy.Merge(m, src)
}
func (m *ActiveClusterSelectionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ActiveClusterSelectionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveClusterSelectionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveClusterSelectionPolicy proto.InternalMessageInfo

func (m *ActiveClusterSelectionPolicy) GetStrategy() ActiveClusterSelectionStrategy {
	if m != nil {
		return m.Strategy
	}
	return ActiveClusterSelectionStrategy_ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID
}

func (m *ActiveClusterSelectionPolicy) GetStickyRegion() string {
	if m != nil {
		return m.StickyRegion
	}
	return ""
}

func (m *ActiveClusterSelectionPolicy) GetExternalEntityType() string {
	if m != nil {
		return m.ExternalEntityType
	}
	return ""
}

func (m *ActiveClusterSelectionPolicy) GetExternalEntityKey() string {
	if m != nil {
		return m.ExternalEntityKey
	}
	return ""
}

func init() {
	proto.RegisterEnum("uber.cadence.api.v1.EncodingType", EncodingType_name, EncodingType_value)
	proto.RegisterEnum("uber.cadence.api.v1.IsolationGroupState", IsolationGroupState_name, IsolationGroupState_value)
	proto.RegisterEnum("uber.cadence.api.v1.ActiveClusterSelectionStrategy", ActiveClusterSelectionStrategy_name, ActiveClusterSelectionStrategy_value)
	proto.RegisterType((*WorkflowExecution)(nil), "uber.cadence.api.v1.WorkflowExecution")
	proto.RegisterType((*WorkflowType)(nil), "uber.cadence.api.v1.WorkflowType")
	proto.RegisterType((*ActivityType)(nil), "uber.cadence.api.v1.ActivityType")
	proto.RegisterType((*Payload)(nil), "uber.cadence.api.v1.Payload")
	proto.RegisterType((*Failure)(nil), "uber.cadence.api.v1.Failure")
	proto.RegisterType((*Memo)(nil), "uber.cadence.api.v1.Memo")
	proto.RegisterMapType((map[string]*Payload)(nil), "uber.cadence.api.v1.Memo.FieldsEntry")
	proto.RegisterType((*Header)(nil), "uber.cadence.api.v1.Header")
	proto.RegisterMapType((map[string]*Payload)(nil), "uber.cadence.api.v1.Header.FieldsEntry")
	proto.RegisterType((*SearchAttributes)(nil), "uber.cadence.api.v1.SearchAttributes")
	proto.RegisterMapType((map[string]*Payload)(nil), "uber.cadence.api.v1.SearchAttributes.IndexedFieldsEntry")
	proto.RegisterType((*DataBlob)(nil), "uber.cadence.api.v1.DataBlob")
	proto.RegisterType((*WorkerVersionInfo)(nil), "uber.cadence.api.v1.WorkerVersionInfo")
	proto.RegisterType((*SupportedClientVersions)(nil), "uber.cadence.api.v1.SupportedClientVersions")
	proto.RegisterType((*RetryPolicy)(nil), "uber.cadence.api.v1.RetryPolicy")
	proto.RegisterType((*IsolationGroupPartition)(nil), "uber.cadence.api.v1.IsolationGroupPartition")
	proto.RegisterType((*IsolationGroupConfiguration)(nil), "uber.cadence.api.v1.IsolationGroupConfiguration")
	proto.RegisterType((*AsyncWorkflowConfiguration)(nil), "uber.cadence.api.v1.AsyncWorkflowConfiguration")
	proto.RegisterType((*ActiveClusterSelectionPolicy)(nil), "uber.cadence.api.v1.ActiveClusterSelectionPolicy")
}

func init() { proto.RegisterFile("uber/cadence/api/v1/common.proto", fileDescriptor_0ff151d4a308b356) }

var fileDescriptor_0ff151d4a308b356 = []byte{
	// 1230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0xfe, 0x6d, 0x9c, 0x7f, 0x3d, 0x76, 0x53, 0x77, 0xd2, 0x3f, 0x6e, 0xda, 0xe4, 0x97, 0x1a,
	0xa1, 0xa6, 0x15, 0xb5, 0x89, 0x23, 0xa4, 0x8a, 0xaa, 0x80, 0x6b, 0x6f, 0x92, 0x6d, 0x82, 0x6d,
	0xc6, 0xdb, 0x86, 0x70, 0xc1, 0x6a, 0xbc, 0x3b, 0x76, 0x07, 0xaf, 0x77, 0xcc, 0xec, 0xac, 0x1b,
	0xdf, 0x20, 0x9e, 0x84, 0x0b, 0x5e, 0x83, 0x17, 0x40, 0xe2, 0x06, 0x89, 0x17, 0x40, 0x7d, 0x08,
	0xae, 0xd1, 0xcc, 0xee, 0xc6, 0x76, 0x71, 0x08, 0x17, 0x88, 0xbb, 0x9d, 0xf3, 0x7d, 0xdf, 0x99,
	0x6f, 0xc6, 0xe7, 0x1c, 0x0f, 0x6c, 0x47, 0x1d, 0x2a, 0xca, 0x2e, 0xf1, 0x68, 0xe0, 0xd2, 0x32,
	0x19, 0xb2, 0xf2, 0x68, 0xb7, 0xec, 0xf2, 0xc1, 0x80, 0x07, 0xa5, 0xa1, 0xe0, 0x92, 0xa3, 0x75,
	0xc5, 0x28, 0x25, 0x8c, 0x12, 0x19, 0xb2, 0xd2, 0x68, 0x77, 0x63, 0xab, 0xc7, 0x79, 0xcf, 0xa7,
	0x65, 0x4d, 0xe9, 0x44, 0xdd, 0xb2, 0x17, 0x09, 0x22, 0x59, 0x2a, 0x2a, 0x1e, 0xc1, 0xf5, 0x13,
	0x2e, 0xfa, 0x5d, 0x9f, 0xbf, 0x31, 0xcf, 0xa8, 0x1b, 0x29, 0x08, 0xfd, 0x1f, 0xb2, 0x6f, 0x92,
	0xa0, 0xc3, 0xbc, 0x82, 0xb1, 0x6d, 0xec, 0x5c, 0xc1, 0x90, 0x86, 0x2c, 0x0f, 0xdd, 0x84, 0x65,
	0x11, 0x05, 0x0a, 0x5b, 0xd0, 0xd8, 0x92, 0x88, 0x02, 0xcb, 0x2b, 0x16, 0x21, 0x97, 0x26, 0xb3,
	0xc7, 0x43, 0x8a, 0x10, 0x2c, 0x06, 0x64, 0x40, 0x93, 0x04, 0xfa, 0x5b, 0x71, 0xaa, 0xae, 0x64,
	0x23, 0x26, 0xc7, 0x17, 0x72, 0x36, 0x61, 0xa5, 0x45, 0xc6, 0x3e, 0x27, 0x9e, 0x82, 0x3d, 0x22,
	0x89, 0x86, 0x73, 0x58, 0x7f, 0x17, 0x9f, 0xc2, 0xca, 0x3e, 0x61, 0x7e, 0x24, 0x28, 0xba, 0x05,
	0xcb, 0x82, 0x92, 0x90, 0x07, 0x89, 0x3e, 0x59, 0xa1, 0x02, 0xac, 0x78, 0x54, 0x12, 0xe6, 0x87,
	0xda, 0x61, 0x0e, 0xa7, 0xcb, 0xe2, 0x0f, 0x06, 0x2c, 0x7e, 0x4e, 0x07, 0x1c, 0x3d, 0x83, 0xe5,
	0x2e, 0xa3, 0xbe, 0x17, 0x16, 0x8c, 0xed, 0xcc, 0x4e, 0xb6, 0xf2, 0x7e, 0x69, 0xce, 0xfd, 0x95,
	0x14, 0xb5, 0xb4, 0xaf, 0x79, 0x66, 0x20, 0xc5, 0x18, 0x27, 0xa2, 0x8d, 0x13, 0xc8, 0x4e, 0x85,
	0x51, 0x1e, 0x32, 0x7d, 0x3a, 0x4e, 0x5c, 0xa8, 0x4f, 0x54, 0x81, 0xa5, 0x11, 0xf1, 0x23, 0xaa,
	0x0d, 0x64, 0x2b, 0xf7, 0xe6, 0xa6, 0x4f, 0x8e, 0x89, 0x63, 0xea, 0xc7, 0x0b, 0x4f, 0x8c, 0xe2,
	0x8f, 0x06, 0x2c, 0x1f, 0x52, 0xe2, 0x51, 0x81, 0x3e, 0x7d, 0xc7, 0xe2, 0x83, 0xb9, 0x39, 0x62,
	0xf2, 0x7f, 0x6b, 0xf2, 0x37, 0x03, 0xf2, 0x6d, 0x4a, 0x84, 0xfb, 0xba, 0x2a, 0xa5, 0x60, 0x9d,
	0x48, 0xd2, 0x10, 0x39, 0xb0, 0xc6, 0x02, 0x8f, 0x9e, 0x51, 0xcf, 0x99, 0xb1, 0xfd, 0x64, 0x6e,
	0xd6, 0x77, 0xe5, 0x25, 0x2b, 0xd6, 0x4e, 0x9f, 0xe3, 0x2a, 0x9b, 0x8e, 0x6d, 0x7c, 0x0d, 0xe8,
	0xaf, 0xa4, 0x7f, 0xf1, 0x54, 0x5d, 0x58, 0xad, 0x13, 0x49, 0x9e, 0xfb, 0xbc, 0x83, 0xf6, 0xe1,
	0x2a, 0x0d, 0x5c, 0xee, 0xb1, 0xa0, 0xe7, 0xc8, 0xf1, 0x30, 0x2e, 0xd0, 0xb5, 0xca, 0xfd, 0xb9,
	0xb9, 0xcc, 0x84, 0xa9, 0x2a, 0x1a, 0xe7, 0xe8, 0xd4, 0xea, 0xbc, 0x80, 0x17, 0xa6, 0x0a, 0xb8,
	0x15, 0x37, 0x1d, 0x15, 0xaf, 0xa8, 0x08, 0x19, 0x0f, 0xac, 0xa0, 0xcb, 0x15, 0x91, 0x0d, 0x86,
	0x7e, 0xda, 0x08, 0xea, 0x1b, 0x3d, 0x80, 0x6b, 0x5d, 0x4a, 0x64, 0x24, 0xa8, 0x33, 0x8a, 0xa9,
	0x49, 0xc3, 0xad, 0x25, 0xe1, 0x24, 0x41, 0xf1, 0x08, 0x6e, 0xb7, 0xa3, 0xe1, 0x90, 0x0b, 0x49,
	0xbd, 0x9a, 0xcf, 0x68, 0x20, 0x13, 0x24, 0x54, 0xbd, 0xda, 0xe3, 0x4e, 0xe8, 0xf5, 0x93, 0xcc,
	0x4b, 0x3d, 0xde, 0xf6, 0xfa, 0xe8, 0x0e, 0xac, 0x7e, 0x43, 0x46, 0x44, 0x03, 0x71, 0xce, 0x15,
	0xb5, 0x6e, 0x7b, 0xfd, 0xe2, 0xf7, 0x19, 0xc8, 0x62, 0x2a, 0xc5, 0xb8, 0xc5, 0x7d, 0xe6, 0x8e,
	0x51, 0x1d, 0xf2, 0x2c, 0x60, 0x92, 0x11, 0xdf, 0x61, 0x81, 0xa4, 0x62, 0x44, 0x62, 0x97, 0xd9,
	0xca, 0x9d, 0x52, 0x3c, 0x5e, 0x4a, 0xe9, 0x78, 0x29, 0xd5, 0x93, 0xf1, 0x82, 0xaf, 0x25, 0x12,
	0x2b, 0x51, 0xa0, 0x32, 0xac, 0x77, 0x88, 0xdb, 0xe7, 0xdd, 0xae, 0xe3, 0x72, 0xda, 0xed, 0x32,
	0x57, 0xd9, 0xd4, 0x7b, 0x1b, 0x18, 0x25, 0x50, 0x6d, 0x82, 0xa8, 0x6d, 0x07, 0xe4, 0x8c, 0x0d,
	0xa2, 0xc1, 0x64, 0xdb, 0xcc, 0xa5, 0xdb, 0x26, 0x92, 0xf3, 0x6d, 0x1f, 0x4e, 0xb2, 0x10, 0x29,
	0xe9, 0x60, 0x28, 0xc3, 0xc2, 0xe2, 0xb6, 0xb1, 0xb3, 0x74, 0x4e, 0xad, 0x26, 0x61, 0xf4, 0x0c,
	0xee, 0x06, 0x3c, 0x70, 0x84, 0x3a, 0x3a, 0xe9, 0xf8, 0xd4, 0xa1, 0x42, 0x70, 0xe1, 0xc4, 0x23,
	0x25, 0x2c, 0x2c, 0x6d, 0x67, 0x76, 0xae, 0xe0, 0x42, 0xc0, 0x03, 0x9c, 0x32, 0x4c, 0x45, 0xc0,
	0x31, 0x8e, 0x5e, 0xc0, 0x3a, 0x3d, 0x1b, 0xb2, 0xd8, 0xc8, 0xc4, 0xf2, 0xf2, 0x65, 0x96, 0xd1,
	0x44, 0x95, 0xba, 0x2e, 0x0e, 0xe0, 0xb6, 0x15, 0x72, 0x5f, 0x07, 0x0f, 0x04, 0x8f, 0x86, 0x2d,
	0x22, 0x24, 0xd3, 0xc3, 0x79, 0xce, 0xc0, 0x44, 0x9f, 0xc0, 0x52, 0x28, 0x89, 0x8c, 0x0b, 0x7e,
	0xad, 0xb2, 0x33, 0xb7, 0x48, 0x67, 0x13, 0xb6, 0x15, 0x1f, 0xc7, 0xb2, 0xe2, 0x08, 0xee, 0xce,
	0xa2, 0x35, 0x1e, 0x74, 0x59, 0x2f, 0x71, 0x88, 0x4e, 0x20, 0xcf, 0x52, 0xd8, 0xe9, 0x29, 0x3c,
	0x6d, 0xed, 0x0f, 0xfe, 0xc1, 0x4e, 0xe7, 0xd6, 0xf1, 0x35, 0x36, 0x03, 0x84, 0xc5, 0x5f, 0x0c,
	0xd8, 0xa8, 0x86, 0xe3, 0xc0, 0x4d, 0xff, 0x36, 0x66, 0xf7, 0x2d, 0xc0, 0x0a, 0x0d, 0xd4, 0x3d,
	0xc7, 0xff, 0x41, 0xab, 0x38, 0x5d, 0xa2, 0x0a, 0xdc, 0x1c, 0x0a, 0xea, 0xd1, 0x2e, 0x0b, 0xa8,
	0xe7, 0x7c, 0x1b, 0xd1, 0x88, 0x3a, 0xfa, 0x56, 0xe2, 0x52, 0x5e, 0x9f, 0x80, 0x5f, 0x28, 0xac,
	0xa1, 0x2e, 0x69, 0x13, 0x20, 0x26, 0xea, 0x76, 0xce, 0x68, 0xe2, 0x15, 0x1d, 0xd1, 0x8d, 0xfa,
	0x19, 0xe4, 0x62, 0xd8, 0xd5, 0x1e, 0x74, 0x91, 0x64, 0x2b, 0x9b, 0x73, 0x0f, 0x98, 0x4e, 0x09,
	0x9c, 0xd5, 0x92, 0xd8, 0x75, 0xf1, 0x0f, 0x03, 0xee, 0xe9, 0xff, 0x36, 0x5a, 0xf3, 0xa3, 0x50,
	0x52, 0xd1, 0xa6, 0x3e, 0x75, 0xd5, 0x49, 0x92, 0x46, 0x6a, 0xc2, 0x6a, 0x28, 0x05, 0x91, 0xb4,
	0x37, 0x4e, 0xc6, 0xc9, 0xde, 0xdc, 0xf4, 0xf3, 0x93, 0xb4, 0x13, 0x29, 0x3e, 0x4f, 0x82, 0xde,
	0x83, 0xab, 0xa1, 0x64, 0x6e, 0x7f, 0xec, 0x08, 0xda, 0x9b, 0x4c, 0x87, 0x5c, 0x1c, 0xc4, 0x3a,
	0x86, 0x3e, 0x84, 0x1b, 0xf4, 0x4c, 0x52, 0x11, 0x10, 0xdf, 0xa1, 0x81, 0x64, 0x72, 0x3c, 0x7d,
	0x03, 0x28, 0xc5, 0x4c, 0x0d, 0xe9, 0xab, 0x28, 0xa9, 0x4a, 0x9e, 0x55, 0xa8, 0x09, 0xbb, 0xa8,
	0x05, 0xd7, 0x67, 0x05, 0x47, 0x74, 0xfc, 0xe8, 0x0d, 0xe4, 0xa6, 0x27, 0x20, 0xba, 0x03, 0x37,
	0xcd, 0x46, 0xad, 0x59, 0xb7, 0x1a, 0x07, 0x8e, 0x7d, 0xda, 0x32, 0x1d, 0xab, 0xf1, 0xaa, 0x7a,
	0x6c, 0xd5, 0xf3, 0xff, 0x43, 0x1b, 0x70, 0x6b, 0x16, 0xb2, 0x0f, 0xb1, 0xb5, 0x6f, 0xe3, 0x93,
	0xbc, 0x81, 0x6e, 0x01, 0x9a, 0xc5, 0x5e, 0xb4, 0x9b, 0x8d, 0xfc, 0x02, 0x2a, 0xc0, 0x8d, 0xd9,
	0x78, 0x0b, 0x37, 0xed, 0xe6, 0x5e, 0x3e, 0xf3, 0xe8, 0x3b, 0x58, 0x9f, 0x53, 0xd5, 0xe8, 0x3e,
	0x6c, 0x5a, 0xed, 0xe6, 0x71, 0xd5, 0xb6, 0x9a, 0x0d, 0xe7, 0x00, 0x37, 0x5f, 0xb6, 0x9c, 0xb6,
	0x5d, 0xb5, 0xa7, 0x7d, 0x5c, 0x48, 0x39, 0x34, 0xab, 0xc7, 0xf6, 0xe1, 0x69, 0xde, 0xb8, 0x98,
	0x52, 0xc7, 0x55, 0xab, 0x61, 0xd6, 0xf3, 0x0b, 0x8f, 0x7e, 0x32, 0x60, 0xeb, 0xef, 0x7f, 0x2c,
	0xf4, 0x18, 0x1e, 0x56, 0x6b, 0xb6, 0xf5, 0xca, 0x74, 0x6a, 0xc7, 0x2f, 0xdb, 0xb6, 0x89, 0x9d,
	0xb6, 0x79, 0x6c, 0xd6, 0x74, 0xd2, 0xb6, 0x8d, 0xab, 0xb6, 0x79, 0x70, 0x3a, 0xe5, 0x6b, 0x0f,
	0xca, 0x97, 0xd3, 0xb1, 0x79, 0x10, 0xaf, 0xad, 0xda, 0x91, 0x72, 0xfa, 0x11, 0xec, 0x5e, 0x2e,
	0x32, 0xbf, 0xb4, 0x4d, 0xdc, 0xa8, 0x1e, 0x3b, 0x66, 0xc3, 0xb6, 0xec, 0xd3, 0xfc, 0xc2, 0xf3,
	0xde, 0xcf, 0x6f, 0xb7, 0x8c, 0x5f, 0xdf, 0x6e, 0x19, 0xbf, 0xbf, 0xdd, 0x32, 0xe0, 0xb6, 0xcb,
	0x07, 0xf3, 0xaa, 0xf1, 0x79, 0xb6, 0xa6, 0x5f, 0x99, 0x2d, 0x35, 0xb8, 0x5a, 0xc6, 0x57, 0xbb,
	0x3d, 0x26, 0x5f, 0x47, 0x9d, 0x92, 0xcb, 0x07, 0xe5, 0xe9, 0x37, 0xe9, 0x63, 0xe6, 0xf9, 0xe5,
	0x1e, 0x8f, 0x5f, 0x9a, 0xc9, 0x03, 0xf5, 0x29, 0x19, 0xb2, 0xd1, 0x6e, 0x67, 0x59, 0xc7, 0xf6,
	0xfe, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x44, 0xab, 0x87, 0x14, 0xc4, 0x0a, 0x00, 0x00,
}

func (m *WorkflowExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkflowId) > 0 {
		i -= len(m.WorkflowId)
		copy(dAtA[i:], m.WorkflowId)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.WorkflowId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivityType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivityType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Failure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Failure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Failure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Memo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Memo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Memo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for k := range m.Fields {
			v := m.Fields[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for k := range m.Fields {
			v := m.Fields[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexedFields) > 0 {
		for k := range m.IndexedFields {
			v := m.IndexedFields[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCommon(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCommon(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataBlob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBlob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataBlob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.EncodingType != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.EncodingType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkerVersionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerVersionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerVersionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FeatureVersion) > 0 {
		i -= len(m.FeatureVersion)
		copy(dAtA[i:], m.FeatureVersion)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.FeatureVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Impl) > 0 {
		i -= len(m.Impl)
		copy(dAtA[i:], m.Impl)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Impl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SupportedClientVersions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportedClientVersions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportedClientVersions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JavaSdk) > 0 {
		i -= len(m.JavaSdk)
		copy(dAtA[i:], m.JavaSdk)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.JavaSdk)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GoSdk) > 0 {
		i -= len(m.GoSdk)
		copy(dAtA[i:], m.GoSdk)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.GoSdk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpirationInterval != nil {
		{
			size, err := m.ExpirationInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.NonRetryableErrorReasons) > 0 {
		for iNdEx := len(m.NonRetryableErrorReasons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NonRetryableErrorReasons[iNdEx])
			copy(dAtA[i:], m.NonRetryableErrorReasons[iNdEx])
			i = encodeVarintCommon(dAtA, i, uint64(len(m.NonRetryableErrorReasons[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaximumAttempts != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.MaximumAttempts))
		i--
		dAtA[i] = 0x20
	}
	if m.MaximumInterval != nil {
		{
			size, err := m.MaximumInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BackoffCoefficient != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BackoffCoefficient))))
		i--
		dAtA[i] = 0x11
	}
	if m.InitialInterval != nil {
		{
			size, err := m.InitialInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsolationGroupPartition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsolationGroupPartition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsolationGroupPartition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsolationGroupConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsolationGroupConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsolationGroupConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IsolationGroups) > 0 {
		for iNdEx := len(m.IsolationGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsolationGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCommon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsyncWorkflowConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsyncWorkflowConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsyncWorkflowConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.QueueConfig != nil {
		{
			size, err := m.QueueConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.QueueType) > 0 {
		i -= len(m.QueueType)
		copy(dAtA[i:], m.QueueType)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.QueueType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PredefinedQueueName) > 0 {
		i -= len(m.PredefinedQueueName)
		copy(dAtA[i:], m.PredefinedQueueName)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PredefinedQueueName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActiveClusterSelectionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveClusterSelectionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveClusterSelectionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalEntityKey) > 0 {
		i -= len(m.ExternalEntityKey)
		copy(dAtA[i:], m.ExternalEntityKey)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ExternalEntityKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExternalEntityType) > 0 {
		i -= len(m.ExternalEntityType)
		copy(dAtA[i:], m.ExternalEntityType)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ExternalEntityType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StickyRegion) > 0 {
		i -= len(m.StickyRegion)
		copy(dAtA[i:], m.StickyRegion)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.StickyRegion)))
		i--
		dAtA[i] = 0x12
	}
	if m.Strategy != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WorkflowExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkflowId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkflowType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Failure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Memo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexedFields) > 0 {
		for k, v := range m.IndexedFields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataBlob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncodingType != 0 {
		n += 1 + sovCommon(uint64(m.EncodingType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerVersionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Impl)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.FeatureVersion)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SupportedClientVersions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GoSdk)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.JavaSdk)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RetryPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialInterval != nil {
		l = m.InitialInterval.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.BackoffCoefficient != 0 {
		n += 9
	}
	if m.MaximumInterval != nil {
		l = m.MaximumInterval.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.MaximumAttempts != 0 {
		n += 1 + sovCommon(uint64(m.MaximumAttempts))
	}
	if len(m.NonRetryableErrorReasons) > 0 {
		for _, s := range m.NonRetryableErrorReasons {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.ExpirationInterval != nil {
		l = m.ExpirationInterval.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsolationGroupPartition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsolationGroupConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IsolationGroups) > 0 {
		for _, e := range m.IsolationGroups {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AsyncWorkflowConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.PredefinedQueueName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.QueueType)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.QueueConfig != nil {
		l = m.QueueConfig.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActiveClusterSelectionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strategy != 0 {
		n += 1 + sovCommon(uint64(m.Strategy))
	}
	l = len(m.StickyRegion)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ExternalEntityType)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ExternalEntityKey)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WorkflowExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkflowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Failure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details[:0], dAtA[iNdEx:postIndex]...)
			if m.Details == nil {
				m.Details = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Memo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]*Payload)
			}
			var mapkey string
			var mapvalue *Payload
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Payload{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]*Payload)
			}
			var mapkey string
			var mapvalue *Payload
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Payload{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexedFields == nil {
				m.IndexedFields = make(map[string]*Payload)
			}
			var mapkey string
			var mapvalue *Payload
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Payload{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IndexedFields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBlob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBlob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBlob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= EncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerVersionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerVersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerVersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Impl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportedClientVersions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportedClientVersions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportedClientVersions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoSdk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoSdk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaSdk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaSdk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialInterval == nil {
				m.InitialInterval = &types.Duration{}
			}
			if err := m.InitialInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackoffCoefficient", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BackoffCoefficient = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaximumInterval == nil {
				m.MaximumInterval = &types.Duration{}
			}
			if err := m.MaximumInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumAttempts", wireType)
			}
			m.MaximumAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumAttempts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonRetryableErrorReasons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonRetryableErrorReasons = append(m.NonRetryableErrorReasons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationInterval == nil {
				m.ExpirationInterval = &types.Duration{}
			}
			if err := m.ExpirationInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsolationGroupPartition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsolationGroupPartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsolationGroupPartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= IsolationGroupState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsolationGroupConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsolationGroupConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsolationGroupConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationGroups = append(m.IsolationGroups, &IsolationGroupPartition{})
			if err := m.IsolationGroups[len(m.IsolationGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsyncWorkflowConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsyncWorkflowConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsyncWorkflowConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredefinedQueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredefinedQueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueConfig == nil {
				m.QueueConfig = &DataBlob{}
			}
			if err := m.QueueConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveClusterSelectionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveClusterSelectionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveClusterSelectionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= ActiveClusterSelectionStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickyRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StickyRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalEntityType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalEntityType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalEntityKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalEntityKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
